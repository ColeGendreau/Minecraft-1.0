name: terraform

on:
  push:
    branches: [ main ]
    paths:
      - "infra/**"
      - "INFRASTRUCTURE_STATE"
  workflow_dispatch:

permissions:
  id-token: write     # required for OIDC
  contents: read

concurrency:
  group: terraform-${{ github.ref }}
  cancel-in-progress: true

jobs:
  apply:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: infra
    
    env:
      ARM_ACCESS_KEY: ${{ secrets.TF_STATE_ACCESS_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Check infrastructure state
        id: check_state
        run: |
          STATE=$(cat ../INFRASTRUCTURE_STATE | tr -d '[:space:]' | tr '[:lower:]' '[:upper:]')
          echo "state=$STATE" >> $GITHUB_OUTPUT
          if [ "$STATE" = "ON" ]; then
            echo "ðŸŸ¢ Infrastructure state: ON - Will provision/update resources"
          elif [ "$STATE" = "OFF" ]; then
            echo "ðŸ”´ Infrastructure state: OFF - Will destroy all resources"
          else
            echo "âš ï¸  Invalid state: $STATE (must be ON or OFF)"
            exit 1
          fi

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          client-id: ${{ secrets.AZURE_CLIENT_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform fmt
        run: terraform fmt -check

      - name: Terraform init
        run: terraform init

      - name: Terraform validate
        run: terraform validate

      - name: Terraform plan (provision)
        if: steps.check_state.outputs.state == 'ON'
        run: terraform plan -out=tfplan

      - name: Terraform apply (provision)
        if: steps.check_state.outputs.state == 'ON' && github.ref == 'refs/heads/main'
        run: |
          terraform apply -auto-approve tfplan
          echo "âœ… Infrastructure provisioned successfully"
      
      - name: Cleanup Kubernetes resources before destroy
        if: steps.check_state.outputs.state == 'OFF' && github.ref == 'refs/heads/main'
        continue-on-error: true
        run: |
          echo "Cleaning up Kubernetes resources that may be using the Public IP..."
          
          # Check if AKS cluster exists
          if az aks show --resource-group mc-demo-dev-rg --name mc-demo-dev-aks &>/dev/null; then
            echo "AKS cluster found. Getting credentials..."
            az aks get-credentials --resource-group mc-demo-dev-rg --name mc-demo-dev-aks --admin --overwrite-existing
            
            # Delete namespaces with LoadBalancer services
            echo "Deleting Kubernetes namespaces..."
            kubectl delete namespace minecraft --ignore-not-found=true --timeout=120s || true
            kubectl delete namespace ingress-nginx --ignore-not-found=true --timeout=120s || true
            
            # Wait a moment for Azure to release the Public IP
            echo "Waiting for Azure to release Public IP..."
            sleep 30
            
            echo "Kubernetes cleanup complete"
          else
            echo "AKS cluster not found, skipping Kubernetes cleanup"
          fi
      
      - name: Terraform destroy (teardown)
        if: steps.check_state.outputs.state == 'OFF' && github.ref == 'refs/heads/main'
        run: |
          echo "ðŸ”´ DESTROYING ALL INFRASTRUCTURE..."
          terraform destroy -auto-approve
          echo "âœ… Infrastructure destroyed successfully"

