# Build and deploy Dashboard + Coordinator containers when code changes
# This runs automatically - you don't need to trigger it manually

name: "Auto: Build Containers"

on:
  push:
    branches: [main]
    paths:
      - 'dashboard/**'
      - 'coordinator-api/**'
      - '.github/workflows/dashboard-deploy.yaml'
  workflow_dispatch:
    inputs:
      deploy_coordinator:
        description: 'Deploy Coordinator API'
        required: false
        default: 'true'
        type: boolean
      deploy_dashboard:
        description: 'Deploy Dashboard'
        required: false
        default: 'true'
        type: boolean

env:
  AZURE_RESOURCE_GROUP: mc-demo-dev-dashboard-rg
  ACR_NAME: mcdemodevdashboardacr
  COORDINATOR_APP: mc-demo-dev-coordinator
  DASHBOARD_APP: mc-demo-dev-dashboard

permissions:
  id-token: write
  contents: read

jobs:
  # Check what changed
  changes:
    runs-on: ubuntu-latest
    outputs:
      coordinator: ${{ steps.filter.outputs.coordinator }}
      dashboard: ${{ steps.filter.outputs.dashboard }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            coordinator:
              - 'coordinator-api/**'
            dashboard:
              - 'dashboard/**'

  # Build and deploy Coordinator API
  deploy-coordinator:
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.coordinator == 'true' || github.event.inputs.deploy_coordinator == 'true'
    
    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Build and push to ACR
        run: |
          # Build in Azure (faster + more reliable than local docker)
          az acr build \
            --registry ${{ env.ACR_NAME }} \
            --image coordinator-api:${{ github.sha }} \
            --image coordinator-api:latest \
            --file coordinator-api/Dockerfile \
            coordinator-api/

      - name: Get Azure OpenAI credentials from main infra
        id: get_openai
        run: |
          # Get Azure OpenAI endpoint and key from the main infrastructure
          OPENAI_ENDPOINT=$(az cognitiveservices account show \
            --name mc-demo-dev-openai \
            --resource-group mc-demo-dev-rg \
            --query "properties.endpoint" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$OPENAI_ENDPOINT" ]; then
            OPENAI_KEY=$(az cognitiveservices account keys list \
              --name mc-demo-dev-openai \
              --resource-group mc-demo-dev-rg \
              --query "key1" -o tsv)
            echo "endpoint=$OPENAI_ENDPOINT" >> $GITHUB_OUTPUT
            echo "key=$OPENAI_KEY" >> $GITHUB_OUTPUT
            echo "configured=true" >> $GITHUB_OUTPUT
            echo "âœ… Azure OpenAI found: $OPENAI_ENDPOINT"
          else
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Azure OpenAI not deployed yet - coordinator will not be able to generate worlds"
          fi

      - name: Get Minecraft server IPs
        id: get_minecraft
        run: |
          # Get AKS credentials to query services
          az aks get-credentials --resource-group mc-demo-dev-rg --name mc-demo-dev-aks --admin --overwrite-existing || true
          
          # Get game server IP (for players to connect)
          GAME_IP=$(kubectl get svc -n minecraft minecraft -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          if [ -n "$GAME_IP" ]; then
            echo "game_ip=$GAME_IP" >> $GITHUB_OUTPUT
            echo "âœ… Minecraft Game IP: $GAME_IP"
          else
            echo "âš ï¸ Minecraft game service not found"
          fi
          
          # Get RCON service IP (for coordinator to send commands)
          RCON_IP=$(kubectl get svc -n minecraft minecraft-rcon -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          if [ -n "$RCON_IP" ]; then
            echo "rcon_ip=$RCON_IP" >> $GITHUB_OUTPUT
            echo "âœ… Minecraft RCON IP: $RCON_IP"
          else
            echo "âš ï¸ Minecraft RCON service not found"
          fi

      - name: Get coordinator identity for AKS auth
        id: get_identity
        run: |
          # Get the coordinator's managed identity client ID for Azure auth
          CLIENT_ID=$(az identity show \
            --name mc-demo-dev-coordinator-identity \
            --resource-group mc-demo-dev-dashboard-rg \
            --query clientId -o tsv 2>/dev/null || echo "")
          
          if [ -n "$CLIENT_ID" ]; then
            echo "client_id=$CLIENT_ID" >> $GITHUB_OUTPUT
            echo "âœ… Coordinator identity client ID: $CLIENT_ID"
          else
            echo "âš ï¸ Coordinator identity not found - kubectl MOTD updates will be disabled"
          fi

      - name: Deploy to Container Apps
        run: |
          # Build environment variables
          ENV_VARS="MINECRAFT_RCON_HOST=${{ steps.get_minecraft.outputs.rcon_ip }} MINECRAFT_RCON_PORT=25575 MINECRAFT_RCON_PASSWORD=worldforge-rcon-2024"
          
          # Add game server IP for dashboard display
          if [ -n "${{ steps.get_minecraft.outputs.game_ip }}" ]; then
            ENV_VARS="$ENV_VARS PUBLIC_IP=${{ steps.get_minecraft.outputs.game_ip }}"
          fi
          
          # Add AKS config for kubectl MOTD updates
          ENV_VARS="$ENV_VARS AKS_RESOURCE_GROUP=mc-demo-dev-rg AKS_CLUSTER_NAME=mc-demo-dev-aks"
          
          if [ -n "${{ steps.get_identity.outputs.client_id }}" ]; then
            ENV_VARS="$ENV_VARS AZURE_CLIENT_ID=${{ steps.get_identity.outputs.client_id }}"
          fi
          
          if [ "${{ steps.get_openai.outputs.configured }}" == "true" ]; then
            ENV_VARS="$ENV_VARS AZURE_OPENAI_ENDPOINT=${{ steps.get_openai.outputs.endpoint }} AZURE_OPENAI_API_KEY=${{ steps.get_openai.outputs.key }} AZURE_OPENAI_DEPLOYMENT=gpt-4o"
          fi
          
          # Update container app with new image and environment
          az containerapp update \
            --name ${{ env.COORDINATOR_APP }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --image ${{ env.ACR_NAME }}.azurecr.io/coordinator-api:${{ github.sha }} \
            --set-env-vars $ENV_VARS
          
          # Set the API key as a secret if OpenAI is configured
          if [ "${{ steps.get_openai.outputs.configured }}" == "true" ]; then
            az containerapp secret set \
              --name ${{ env.COORDINATOR_APP }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --secrets openai-key="${{ steps.get_openai.outputs.key }}"
            
            az containerapp update \
              --name ${{ env.COORDINATOR_APP }} \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --set-env-vars "AZURE_OPENAI_API_KEY=secretref:openai-key"
          fi

  # Build and deploy Dashboard
  deploy-dashboard:
    runs-on: ubuntu-latest
    needs: [changes, deploy-coordinator]
    # Run if dashboard changed OR manually triggered, but wait for coordinator if it's deploying
    if: |
      always() && 
      (needs.changes.outputs.dashboard == 'true' || github.event.inputs.deploy_dashboard == 'true') &&
      (needs.deploy-coordinator.result == 'success' || needs.deploy-coordinator.result == 'skipped')

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Coordinator URL
        id: get_url
        run: |
          COORDINATOR_URL=$(az containerapp show \
            --name ${{ env.COORDINATOR_APP }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" -o tsv)
          echo "url=https://${COORDINATOR_URL}" >> $GITHUB_OUTPUT

      - name: Build and push to ACR
        run: |
          # Build in Azure (faster + more reliable than local docker)
          az acr build \
            --registry ${{ env.ACR_NAME }} \
            --image dashboard:${{ github.sha }} \
            --image dashboard:latest \
            --build-arg NEXT_PUBLIC_API_URL=${{ steps.get_url.outputs.url }} \
            --file dashboard/Dockerfile \
            dashboard/

      - name: Deploy to Container Apps
        run: |
          az containerapp update \
            --name ${{ env.DASHBOARD_APP }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --image ${{ env.ACR_NAME }}.azurecr.io/dashboard:${{ github.sha }}

      - name: Output Dashboard URL
        run: |
          DASHBOARD_URL=$(az containerapp show \
            --name ${{ env.DASHBOARD_APP }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" -o tsv)
          echo "ðŸš€ Dashboard deployed to: https://${DASHBOARD_URL}"
